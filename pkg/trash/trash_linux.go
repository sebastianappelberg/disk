//go:build linux

// Package trash.
// This file contains code from the project github.com/Kei-K23/trashbox,
// with modifications to fit the rest of the project.
// Source: https://github.com/Kei-K23/trashbox.
// License: MIT
package trash

import (
	"encoding/json"
	"errors"
	"os"
	"path/filepath"
)

type metadata struct {
	OriginalPath string `json:"original_path"`
}

// Put moves the specified files or directories to the Linux Trash.
//
// This function takes the path multiple files or directories as an argument,
// converts it to an absolute path, and then moves it to the user's
// Trash directory located at ~/.local/share/Trash/files. If the
// provided path does not exist, or if the Trash directory does not
// exist, an error will be returned.
//
// If the operation is successful, the file or directory will no
// longer exist at the original path and will be relocated to the
// Trash for potential recovery.
//
// Parameters:
//   - filePaths: The path of the files or directories to be moved to Trash.
//
// Returns:
//   - error: Returns nil on success. If an error occurs during the
//     process (e.g., if the file does not exist or the move fails),
//     an error will be returned explaining the reason for failure.
//     Specifically, if the Trash directory does not exist, an
//     error indicating that will be returned.
//
// Example:
//
//	err := Put("path/to/your/file.txt")
//	if err != nil {
//	    log.Fatalf("Failed to move to Trash: %v", err)
//	}
func Put(filePaths ...string) error {
	for _, filePath := range filePaths {
		err := put(filePath)
		if err != nil {
			return err
		}
	}
	return nil
}

func put(path string) error {
	absPath, err := filepath.Abs(path)
	if err != nil {
		return err
	}

	// Get the file path to trash file
	trashDir := getTrashDir()
	if _, err = os.Stat(trashDir); os.IsNotExist(err) {
		return errors.New("trash directory does not exist")
	}

	trashPath := filepath.Join(trashDir, filepath.Base(absPath))
	// Move the file to trash directory
	err = os.Rename(absPath, trashPath)
	if err != nil {
		return err
	}

	// Create metadata file for recovery the deleted file
	metadata := metadata{OriginalPath: absPath}
	metadataPath := trashPath + ".metadata.json"

	// Create metadata file in Trash bin
	metadataFile, err := os.Create(metadataPath)
	if err != nil {
		return err
	}
	defer metadataFile.Close()

	encoder := json.NewEncoder(metadataFile)
	err = encoder.Encode(metadata)
	if err != nil {
		return err
	}

	return nil
}

// Restore restores a previously deleted file from the Trash to its original location.
// The original location is determined from the metadata generated when the file was moved to Trash.
//
// Parameters:
//
//	path (string): The name of the file or directory to be restored from Trash.
//
// Returns:
//
//	error: Returns an error if the file cannot be restored or if there are issues
//	       with reading the metadata file. Returns nil if successful.
//
// Example usage:
//
//	err := Restore("file.txt")
//	if err != nil {
//	    log.Fatalf("Failed to put back file from Trash: %v", err)
//	}
//
// Notes:
//   - The function depends on a metadata file (generated by Put) being present
//     in the Trash directory, which contains the original path.
//   - On success, the metadata file is removed from the Trash.
func Restore(path string) error {
	// Get the Trash box path and metadata path
	trashPath := getTrashDir()
	metadataPath := trashPath + ".metadata.json"

	// Open metadata file to get original file path
	metadataFile, err := os.Open(metadataPath)
	if err != nil {
		return err
	}
	defer metadataFile.Close()

	var metadata metadata
	decoder := json.NewDecoder(metadataFile)
	err = decoder.Decode(&metadata)
	if err != nil {
		return err
	}

	// Put back file to original path
	err = os.Rename(trashPath, metadata.OriginalPath)
	if err != nil {
		return err
	}

	// Remove the metadata file
	err = os.Remove(metadataPath)
	if err != nil {
		return err
	}

	return nil
}

func getTrashDir() string {
	return filepath.Join(os.Getenv("HOME"), ".local/share/Trash/files")
}
